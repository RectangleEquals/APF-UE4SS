"""
AP Framework World for Archipelago.

This is a template/base world for games using the AP Framework mod system.
It dynamically creates items and locations from a capabilities config file
generated by the in-game framework.

To create a game-specific world:
1. Copy this directory to your Archipelago/worlds/<game_name> folder
2. Update the game name and other constants
3. Optionally override methods to add game-specific logic
"""

from typing import Dict, List, Any, ClassVar, Set
import json
import os

from BaseClasses import Item, Location, Region, Tutorial, ItemClassification, MultiWorld
from worlds.AutoWorld import World, WebWorld

from .Items import APFrameworkItem, ItemData, build_item_table, get_filler_items, get_trap_items
from .Locations import APFrameworkLocation, LocationData, build_location_table
from .Options import APFrameworkOptions
from .Rules import set_rules, set_completion_rules


class APFrameworkWebWorld(WebWorld):
    """Web world for displaying game info on the Archipelago website."""
    theme = "jungle"

    tutorials = [
        Tutorial(
            "Multiworld Setup Guide",
            "A guide to setting up the AP Framework multiworld.",
            "English",
            "setup_en.md",
            "setup/en",
            ["AP Framework Team"]
        )
    ]


class APFrameworkWorld(World):
    """
    AP Framework World - A template for games using the AP Framework mod system.

    This world reads item and location definitions from a capabilities config
    file generated by the in-game framework, allowing any game with AP Framework
    mods to be randomized in Archipelago.
    """

    # =========================================================================
    # Class Variables - Override these in game-specific subclasses
    # =========================================================================

    game: ClassVar[str] = "APFramework"  # Change to your game's name
    web: ClassVar[WebWorld] = APFrameworkWebWorld()

    options_dataclass = APFrameworkOptions
    options: APFrameworkOptions

    # Topology: 0 = no logic, 1 = basic, 2 = advanced
    topology_present: ClassVar[bool] = False

    # =========================================================================
    # Instance Variables
    # =========================================================================

    item_table: Dict[str, ItemData]
    location_table: Dict[str, LocationData]
    capabilities: Dict[str, Any]
    id_remapping: Dict[int, int]

    # Item/Location name to ID mappings (required by Archipelago)
    item_name_to_id: ClassVar[Dict[str, int]] = {}
    location_name_to_id: ClassVar[Dict[str, int]] = {}

    # =========================================================================
    # Initialization
    # =========================================================================

    def __init__(self, multiworld: MultiWorld, player: int):
        super().__init__(multiworld, player)
        self.item_table = {}
        self.location_table = {}
        self.capabilities = {}
        self.id_remapping = {}

    # =========================================================================
    # World Generation
    # =========================================================================

    def generate_early(self) -> None:
        """
        Load capabilities config file and set up item/location tables.
        Called before item/location creation.
        """
        # Get capabilities file path from options
        cap_filename = self.options.capabilities_file.value
        if not cap_filename:
            raise Exception(
                f"[{self.game}] capabilities_file option is required.\n"
                "Please specify the path to your AP_Capabilities_<slot>.json file."
            )

        # Build full path - check Players directory
        # First try relative to worlds directory
        worlds_dir = os.path.dirname(os.path.dirname(__file__))
        players_dir = os.path.join(worlds_dir, "..", "Players")
        cap_path = os.path.join(players_dir, cap_filename)

        # Normalize path
        cap_path = os.path.normpath(cap_path)

        # Load capabilities
        if not os.path.exists(cap_path):
            # Try as absolute path
            if os.path.exists(cap_filename):
                cap_path = cap_filename
            else:
                raise Exception(
                    f"[{self.game}] Capabilities file not found: {cap_path}\n"
                    f"Please copy your AP_Capabilities file to the Players directory."
                )

        self.capabilities = self.load_capabilities(cap_path)

        # Build item and location tables
        self.item_table = build_item_table(self.capabilities)
        self.location_table = build_location_table(self.capabilities)

        # Update class-level ID mappings (required for item/location creation)
        self.__class__.item_name_to_id = {
            name: data.code for name, data in self.item_table.items()
        }
        self.__class__.location_name_to_id = {
            name: data.code for name, data in self.location_table.items()
        }

        # Check for ID conflicts with other worlds
        self.check_id_conflicts()

    def load_capabilities(self, path: str) -> dict:
        """Load and validate capabilities config file."""
        try:
            with open(path, encoding="utf-8") as f:
                data = json.load(f)

            # Validate required fields
            required = ["version", "game", "locations", "items", "checksum"]
            for field in required:
                if field not in data:
                    raise ValueError(f"Missing required field: {field}")

            return data

        except json.JSONDecodeError as e:
            raise Exception(f"[{self.game}] Invalid JSON in capabilities file: {e}")

    def check_id_conflicts(self) -> None:
        """Check for ID conflicts with other worlds and remap if necessary."""
        # Collect all IDs used by other worlds
        used_ids: Set[int] = set()

        for world in self.multiworld.worlds.values():
            if world.player == self.player:
                continue

            # Get location IDs
            for loc in world.multiworld.get_locations(world.player):
                if loc.address is not None:
                    used_ids.add(loc.address)

            # Get item IDs
            for item_name, item_id in getattr(world, "item_name_to_id", {}).items():
                if item_id is not None:
                    used_ids.add(item_id)

        # Check for conflicts
        my_location_ids = {data.code for data in self.location_table.values()}
        my_item_ids = {data.code for data in self.item_table.values()}
        my_ids = my_location_ids | my_item_ids

        conflicts = my_ids & used_ids

        if conflicts:
            self.remap_ids(conflicts, used_ids)

    def remap_ids(self, conflicting_ids: Set[int], all_used_ids: Set[int]) -> None:
        """Remap conflicting IDs to safe values."""
        # Find safe starting point
        all_my_ids = {data.code for data in self.item_table.values()}
        all_my_ids |= {data.code for data in self.location_table.values()}
        all_ids = all_used_ids | all_my_ids

        safe_start = max(all_ids) + 1000 if all_ids else self.capabilities.get("id_base", 6942067) + 100000

        # Build remapping
        remap: Dict[int, int] = {}
        for old_id in sorted(conflicting_ids):
            remap[old_id] = safe_start
            safe_start += 1

        self.id_remapping = remap

        # Apply remapping to location table
        new_location_table = {}
        for name, data in self.location_table.items():
            new_code = remap.get(data.code, data.code)
            new_location_table[name] = LocationData(
                code=new_code,
                name=data.name,
                mod_id=data.mod_id,
                instance=data.instance,
                region=data.region
            )
        self.location_table = new_location_table

        # Apply remapping to item table
        new_item_table = {}
        for name, data in self.item_table.items():
            new_code = remap.get(data.code, data.code)
            new_item_table[name] = ItemData(
                code=new_code,
                name=data.name,
                classification=data.classification,
                mod_id=data.mod_id,
                count=data.count
            )
        self.item_table = new_item_table

        # Update class-level mappings
        self.__class__.item_name_to_id = {
            name: data.code for name, data in self.item_table.items()
        }
        self.__class__.location_name_to_id = {
            name: data.code for name, data in self.location_table.items()
        }

    def create_regions(self) -> None:
        """Create regions and locations."""
        # Create Menu region (required by Archipelago)
        menu_region = Region("Menu", self.player, self.multiworld)
        self.multiworld.regions.append(menu_region)

        # Create Main region (all locations go here by default)
        main_region = Region("Main", self.player, self.multiworld)

        # Create locations
        for loc_name, loc_data in self.location_table.items():
            location = APFrameworkLocation(
                self.player,
                loc_name,
                loc_data.code,
                main_region
            )
            main_region.locations.append(location)

        # Connect Menu to Main
        menu_region.connect(main_region)

        self.multiworld.regions.append(main_region)

    def create_items(self) -> None:
        """Create items and add to item pool."""
        # Count total locations
        total_locations = len(self.location_table)

        # Create defined items first
        items_created = 0
        filler_item_names = []

        for item_name, item_data in self.item_table.items():
            if item_data.count == -1:
                # This is a filler item - save for later
                filler_item_names.append(item_name)
                continue

            # Create specified count of this item
            for _ in range(item_data.count):
                item = APFrameworkItem(
                    item_name,
                    item_data.classification,
                    item_data.code,
                    self.player
                )
                self.multiworld.itempool.append(item)
                items_created += 1

        # Fill remaining slots with filler items
        remaining = total_locations - items_created

        if remaining > 0 and filler_item_names:
            # Get trap chance
            trap_chance = self.options.trap_item_chance.value / 100.0
            trap_items = get_trap_items(self.item_table)

            import random
            for i in range(remaining):
                # Determine if this should be a trap
                if trap_items and random.random() < trap_chance:
                    item_name = random.choice(trap_items)
                else:
                    item_name = random.choice(filler_item_names)

                item_data = self.item_table[item_name]
                item = APFrameworkItem(
                    item_name,
                    item_data.classification,
                    item_data.code,
                    self.player
                )
                self.multiworld.itempool.append(item)

    def set_rules(self) -> None:
        """Set access rules for locations."""
        set_rules(self)
        set_completion_rules(self)

    def fill_slot_data(self) -> Dict[str, Any]:
        """Return data to be sent to the client."""
        return {
            "capabilities_checksum": self.capabilities.get("checksum", ""),
            "id_remapping": self.id_remapping,
            "game_name": self.capabilities.get("game", self.game),
            "validate_checksum": bool(self.options.validate_checksum.value),
        }

    def get_filler_item_name(self) -> str:
        """Get a random filler item name."""
        filler_items = get_filler_items(self.item_table)
        if filler_items:
            import random
            return random.choice(filler_items)
        # Fallback - return first item
        if self.item_table:
            return next(iter(self.item_table.keys()))
        return "Nothing"
